判断一个数是否是2的N次方，以及求这个数的最大的2的幂

循环方法略去O(logn)

位移计算O(1);

```c
if((N & (N-1)) == 0) {
  yes
}
else{
  false
}
```

N为正数的时候可以使用

不大于N的最大的2的幂

```c
int largest_power(int N) {
  N = N | (N >> 1);
  N = N | (N >> 2);
  N = N | (N >> 4);
  N = N | (N >> 8);
  N = N | (N >> 16);
  return (N + 1) >> 1;
}
```

原理对于正数N，其不大于本身的2的n次方可以只保留第一个二进制中的1，其余用0表示。

即0100...00 -> 0111...11 + 1 >> 1

将其余的1全部转化为0：

已知 第一个1（kbit处）则 N | (N >> 1) 可以保证 k k + 1bit为1

数学归纳法

第i次(1开始) | 的时候可以保证[k, k + 2^(i-1)]为1

第i+1次可以保证[k, k + 2^i]为1 ...




